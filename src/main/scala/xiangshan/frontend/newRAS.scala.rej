diff a/src/main/scala/xiangshan/frontend/newRAS.scala b/src/main/scala/xiangshan/frontend/newRAS.scala	(rejected hunks)
@@ -145,6 +145,8 @@ class RAS(implicit p: Parameters) extends BasePredictor {
     val TOSW = RegInit(RASPtr(false.B, 0.U))
     val BOS = RegInit(RASPtr(false.B, 0.U))
 
+    val spec_overflowed = RegInit(false.B)
+
     val writeBypassEntry = Reg(new RASEntry)
     val writeBypassNos = Reg(new RASPtr)
 
@@ -286,6 +288,11 @@ class RAS(implicit p: Parameters) extends BasePredictor {
         ssp := ptrInc(currentSsp)
         sctr := 0.U
       }
+      // if we are draining the capacity of spec queue, force move BOS forward
+      when (specPtrInc(currentTOSW) === BOS) {
+        BOS := specPtrInc(BOS)
+        spec_overflowed := true.B;
+      }
     }
 
     when (io.spec_push_valid) {
@@ -299,9 +306,15 @@ class RAS(implicit p: Parameters) extends BasePredictor {
       // spec sp and ctr should always be maintained
       when (currentSctr > 0.U) {
         sctr := currentSctr - 1.U
+      } .elsewhen (TOSRinRange(currentTopNos, currentTOSW)) {
+        // in range, use inflight data
+        ssp := ptrDec(currentSsp)
+        sctr := spec_queue(currentTopNos.value).ctr
       } .otherwise {
+        // NOS not in range, use commit data
         ssp := ptrDec(currentSsp)
         sctr := getCommitTop(ptrDec(currentSsp)).ctr
+        // in overflow state, we cannot determine the next sctr, sctr here is not accurate
       }
     }
     when (io.spec_pop_valid) {
@@ -337,29 +350,54 @@ class RAS(implicit p: Parameters) extends BasePredictor {
     val commitTop = commit_stack(nsp)
 
     when (io.commit_pop_valid) {
+
+      val nsp_update = Wire(UInt(log2Up(rasSize).W))
+      when (io.commit_meta_ssp =/= nsp) {
+        // force set nsp to commit ssp to avoid permanent errors
+        nsp_update := io.commit_meta_ssp
+      } .otherwise {
+        nsp_update := nsp
+      }
+
       // if ctr > 0, --ctr in stack, otherwise --nsp
       when (commitTop.ctr > 0.U) {
-        commit_stack(nsp).ctr := commitTop.ctr - 1.U
+        commit_stack(nsp_update).ctr := commitTop.ctr - 1.U
+        nsp := nsp_update
       } .otherwise {
-        nsp := ptrDec(nsp);
+        nsp := ptrDec(nsp_update);
       }
-      XSError(io.commit_meta_ssp =/= nsp, "nsp mismatch with expected ssp")
+      // XSError(io.commit_meta_ssp =/= nsp, "nsp mismatch with expected ssp")
     }
 
     val commit_push_addr = spec_queue(io.commit_meta_TOSW.value).retAddr
 
+    
+
     when (io.commit_push_valid) {
+      val nsp_update = Wire(UInt(log2Up(rasSize).W))
+      when (io.commit_meta_ssp =/= nsp) {
+        // force set nsp to commit ssp to avoid permanent errors
+        nsp_update := io.commit_meta_ssp
+      } .otherwise {
+        nsp_update := nsp
+      }
       // if ctr < max && topAddr == push addr, ++ctr, otherwise ++nsp
       when (commitTop.ctr < ctrMax && commitTop.retAddr === commit_push_addr) {
-        commit_stack(nsp).ctr := commitTop.ctr + 1.U
+        commit_stack(nsp_update).ctr := commitTop.ctr + 1.U
+        nsp := nsp_update
       } .otherwise {
-        nsp := ptrInc(nsp)
-        commit_stack(ptrInc(nsp)).retAddr := commit_push_addr
-        commit_stack(ptrInc(nsp)).ctr := 0.U
+        nsp := ptrInc(nsp_update)
+        commit_stack(ptrInc(nsp_update)).retAddr := commit_push_addr
+        commit_stack(ptrInc(nsp_update)).ctr := 0.U
+      }
+      // when overflow, BOS may be forced move forward, do not revert those changes
+      when (!spec_overflowed || isAfter(specPtrInc(io.commit_meta_TOSW), BOS)) {
+        BOS := specPtrInc(io.commit_meta_TOSW)
+        spec_overflowed := false.B
       }
-      BOS := specPtrInc(io.commit_meta_TOSW)
-      XSError(io.commit_meta_ssp =/= nsp, "nsp mismatch with expected ssp")
-      XSError(io.commit_push_addr =/= commit_push_addr, "addr from commit mismatch with addr from spec")
+      
+      // XSError(io.commit_meta_ssp =/= nsp, "nsp mismatch with expected ssp")
+      // XSError(io.commit_push_addr =/= commit_push_addr, "addr from commit mismatch with addr from spec")
     }
     
     when (io.redirect_valid) {
